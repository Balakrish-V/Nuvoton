#include "MS51_32K.h"
#include <math.h>
/*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
							i/o init routine
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
//#define 	voltup  	  P14//triac 1-output mode
//#define 	voltdn  	  P13//triac2 -output mode
//#define 	cutoff  	  P11//internal relay output mode
//#define   extcutoff   P12//external relay output mode
#define   CARRY CY

//#define		  buzzer	        P35
/*#define     ipredled        P15//RA1
#define     ipgreenled      P15//RC3
#define     rgbredled       P15//RC6
#define     rgbblueled      P15//RA4*/

#define 	chip  	P10
#define 	enab 		P33
#define   ddata    P16
sbit dclock=P2^1;
sbit PROXIMITY_SENSOR = P1^1;

//#define    ENABLE1_ADC_CH10       P22_INPUT_MODE;SFRS=0;ADCCON0&=0x30;ADCCON0|=0x0A;AINDIDS1=0;AINDIDS1|=0x04;ADCCON1|=0x31;//input section
//#define    ENABLE1_ADC_CH11       P23_INPUT_MODE;SFRS=0;ADCCON0&=0x30;ADCCON0|=0x0B;AINDIDS1=0;AINDIDS1|=0x08;ADCCON1|=0x31;//output section
#define    ENABLE1_ADC_CH12       P24_INPUT_MODE;SFRS=0;ADCCON0&=0x30;ADCCON0|=0x0C;AINDIDS1=0;AINDIDS1|=0x10;ADCCON1|=0x31;//CT section
#define    ADC_CHANNEL_12  12   // P2.4 = ADC12
#define    ENABLE1_ADC_CH15       P25_INPUT_MODE;SFRS=0;ADCCON0&=0x30;ADCCON0|=0x0F;AINDIDS1=0;AINDIDS1|=0x80;ADCCON1|=0x31;//switch
/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
							lookup table routine
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
											  constant  declaration
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
#define dp '.'
#define hi '-'
#define ha '/'
#define ac ':'
#define nu ' ' 
#define ast '*'
#define ca 'A'
#define cb 'B'
#define cc 'C'
#define cd 'D'
#define ce 'E'
#define cf 'F'
#define cg 'G'
#define ch 'H'
#define ci 'I'
#define cj 'J'
#define ck 'K'
#define cl 'L'
#define cm 'M'
#define cn 'N' 
#define co 'O' 
#define cp 'P' 
#define cq 'Q'
#define cr 'R'
#define cs 'S'
#define ct 'T'
#define cu 'U'
#define cv 'V' 
#define cw 'W'
#define cx 'X' 
#define cy 'Y'
#define cz 'Z' 
#define da '0'
#define db '1'
#define dc '2'
#define dd '3'
#define de '5'
#define di '6'
#define df '7'
#define dg '8'
#define dp '.'

#define sa 'a'
#define sb 'b'
#define sc 'c'
#define sd 'd'
#define se 'e'
#define sf 'f'
#define sg 'g'
#define sh 'h'
#define si 'i'
#define sj 'j'
#define sk 'k'
#define sl 'l'
#define sm 'm'
#define sn 'n' 
#define so 'o'
#define sp 'p' 
#define sq 'q'
#define sr 'r'
#define ss 's'
#define st 't'
#define su 'u'
#define sv 'v' 
#define sw 'w'
#define sx 'x' 
#define sy 'y'
#define sz 'z'

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
							lcd initialisation values routine
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
xdata const char init2[]={0x38,0xa0,0x38,0x0a,0x08,0x0a,0x01,0x0a,0x06,0x0a,0x0f,0x0a,0x80,0x0a,0x01,0x0a};
//const char init2[]={0x38,0x0a,0x38,0x01,0x08,0x01,0x01,0x05,0x06,0x01,0x0f,0x01,0x80,0x01,0x01,0x00};

/*******************************Main display***************************************************/
xdata const char temperaturestring[]= {ct,cm,cp,':',nu,nu,cc,nu,cv,':',nu,nu,nu,sm,sm,ss};
xdata const char proximitystring[]=   {ch,cr,cs,':',nu,nu,nu,nu,cl,cv,cl,':',nu,nu,nu,'%'};
xdata const char temp_maximum[] = { nu, cm, ca, cx, hi, ct, ce, cm, cp, ac, nu, nu, nu, cc, nu, nu};
xdata const char oil_lowlvl[] = { co, ci, cl, nu, cl, co, cw, hi, cl, cv, cl, ac, nu, nu, nu, '%' };
xdata const char max_vib[] = { cm, ca, cx, hi, cv, ci, cb, ac, nu, nu, nu, nu, sm, sm, ha, ss };
xdata const char run_time[] = { nu, cr, cu, cn, hi, ct, ci, cm, ce, ac, nu, nu, nu, nu, nu, nu };

xdata const char machine_status[] = { nu, cm, ca, cc, ch, ci, cn, ce, nu, cs, ct, ca, ct, cu, cs, nu };
xdata const char machine_line2[] = { ch, ac, nu, nu, nu, nu, nu, cv, ac, nu, nu, nu, sm, sm, ha, ss };
xdata const char coolant_status[] = { nu, cc, co, co, cl, ca, cn, ct, nu, cs, ct, ca, ct, cu, cs, nu };
xdata const char coolant_line2[] = { ct, cm, cp, ac, nu, nu, cc, nu, cl, cv, cl, ac, nu, nu, nu, '%'};

xdata const char cusname[]=	    {nu,nu,cl,sa,sk,ss,sh,sm,si,nu,cc,sa,sr,sd,nu,nu};//Cus
xdata const char cusnum[]=		{nu,nu,nu,'9','8','4','3','9','3','3','8','0','8',nu,nu,nu};
xdata const char modd0[]=          {cr,ct,cc,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu};
xdata const char modd1[]=          {ct,cr,cg,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu};
xdata const char frwd[]=           {cf,cw,cd,nu,nu,nu,nu,nu,nu,co,cf,ct,':',nu,nu,nu};
xdata const char rrev[]=           {cr,ce,cv,nu,nu,nu,nu,nu,nu,co,cf,ct,':',nu,nu,nu};
xdata const char fault[]=          {cf,ca,cu,cl,ct,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu};
xdata const char parkk[]=          {cp,ca,cr,ck,nu,nu,nu,nu,nu,co,cf,ct,':',nu,nu,nu};
xdata const char eoc[]=			{ce,co,cc,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu};
xdata const char eoc1[]=			{ce,co,cc,nu,nu,nu,nu,nu,nu,co,cf,ct,':',nu,nu,nu};


xdata const char rt1n[]=          {nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,ct,db,':',co,cn,nu};
xdata const char rt1f[]=          {nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,ct,db,':',co,cf,cf};
xdata const char rt2n[]=          {nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,ct,dc,':',co,cn,nu};
xdata const char rt2f[]=          {nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,ct,dc,':',co,cf,cf};
xdata const char tmrtrg[]=       {nu,nu,nu,nu,nu,nu,nu,co,cf,ct,'-',nu,nu,nu,nu,nu};

/************************Settings display*********************************************************/
xdata const char fline1[]=	{nu,nu,nu,nu,cs,se,st,nu,sm,so,sd,se,nu,nu,nu,nu};//Set mode

xdata const char mod1[]=		{nu,nu,cm,so,sd,se,':',cr,ct,cc,nu,nu,nu,nu,nu,nu};//Mode:RTC
xdata const char mod2[]=		{nu,nu,cm,so,sd,se,':',ct,cr,ci,cg,cg,ce,cr,nu,nu};//Mode:TRIGGER

xdata const char ten[]=		{cr,cu,cn,ct,si,sm,se,'(',cm,')',':',nu,nu,nu,nu,nu};//RUNTime(M):
xdata const char rt1[]=		{ct,db,co,cn,'(',ch,':',cm,')','-',nu,nu,nu,nu,nu,nu};//T1ON(H:M)-
xdata const char rt2[]=		{ct,db,co,cf,'(',ch,':',cm,')','-',nu,nu,nu,nu,nu,nu};//T1OF(H:M)-
xdata const char rt3[]=		{ct,dc,co,cn,'(',ch,':',cm,')','-',nu,nu,nu,nu,nu,nu};//T2ON(H:M)-
xdata const char rt4[]=		{ct,dc,co,cf,'(',ch,':',cm,')','-',nu,nu,nu,nu,nu,nu};//T2OF(H:M)-
xdata const char flt[]=		{cf,cl,ct,cs,cn,cs,ce,'(',cs,')',':',nu,nu,nu,nu,nu};//FLTSNSE(s):
xdata const char prk[]=		{cp,cr,ck,ct,ci,cm,ce,'(',cs,')',':',nu,nu,nu,nu,nu};//PRKTIME(s):
xdata const char spd1[]=		{cm,so,st,so,sr,nu,'%',nu,':',de,da,nu,nu,nu,nu,nu};//Motor % :30
xdata const char spd2[]=		{cm,so,st,so,sr,nu,'%',nu,':',di,de,nu,nu,nu,nu,nu};//Motor % :50
xdata const char spd3[]=		{cm,so,st,so,sr,nu,'%',nu,':',dg,da,nu,nu,nu,nu,nu};//Motor % :75
xdata const char spd4[]=		{cm,so,st,so,sr,nu,'%',nu,':',db,da,da,nu,nu,nu,nu};//Motor % :100
xdata const char rtc[]=		{cr,ct,cc,'(',ch,':',cm,')',nu,'-',nu,nu,nu,nu,nu,nu};//RTC(H:M) -
xdata const char home[] = 	{ch,co,cm,ce,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu};
xdata const char trighome[] =  {ch,co,cm,ce,nu,nu,nu,nu,nu,co,cf,ct,':',nu,nu,nu};
xdata const char space[] = {nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu,nu};

xdata char automan=0,swrelease=0,datachang=0,chang=0,mpress=0,spress=0,ipress=0;
xdata char menukey=0,sidekey=0,inckey=0,setrun=0;
xdata char fwdflag;

xdata char hr=0,sec=0,hour=0,minute=0,initialsense=0,date=0,month=0,year=0,buf1=0,buf2=0,date1=0,mont1=0,hou1=0,minut1=0,msec=0;
xdata char eemem=0,txbuf=0,datai=0,buff=0,ibm=0,phsp=0,dbuf[5],aman=0,speed=2,speed_flag=0,disdat=0,cursor=0,clearinglog=0,i=0;
xdata char count=0,menu=0,blink=0,cblink=0,digit1[5],smenu=0,sensi=0,menu_change=0;
xdata char h=0,menu1=0,t1n=0,t1f=0,t2n=0,t2f=0,oft=0,park=0;
xdata char j=0,a=0,b=0,c=0,d=0,k=0;
xdata char address=0,lmenu=0,adcome=0;
xdata char setruntime=0,sidetime=0,inctime=0,menutime=0;
xdata unsigned char switchpress=0;
xdata unsigned int temp_min=0,temp_max=0,oil_level=0,count_save=0,rtz2f_timer=0,park_time=0,fault_time=0,trig_timer=0,rtc_time=0;
xdata unsigned int buffer=0,result=0,result1=0,parkrun=0,tempmax=0, oil_low_level = 0, max_vib_var = 0, run_time_var = 0,sensetimes=0,countlimit=0;
xdata unsigned int counter2=0,counter4=0;
xdata unsigned int m=0,n=0,o=0,timerhigh=0;
xdata unsigned char setswitch=0;
xdata unsigned int duty=0,readrom=0,doad=0;
xdata unsigned int swactive=0,pwmspeed=0;
xdata unsigned char forwardstart=0,revstart=0;
xdata unsigned char set_bit_check = 0;
xdata char offtimerflag,rtcdispflag, dispsecflag,dispfirstflag,countflag,countfaultflag,tempfaultflag,trigOk,cleancycle,timeok,faultstartcheck,trigover,endtrig1;
xdata char endofcycleflagrtc,endofcycleflagtrg,eoctrglck,eoctrgwrite,eocrtcwrite;

xdata uint16_t vib_level = 0,  time_set = 0;
xdata uint16_t temp_adc_result = 0,  sw_adc_result = 0;

xdata unsigned char oneminute=0,rtcdispcount=0, secondscount=0,faultsec=0,faultcount=0,faultstartcount=0,rtcdisplaystate=0,faultime=0;
xdata unsigned char setbit=0,endtrig=0,endcheck=0,trigcheck=0,trigruncomplete=0,mainscreen=0,rtcruncomplete=0;
xdata unsigned int triggertimertemp=0,offtimcount=0,trigsec=0, endsec=0,rtcnow=0,futuretime=0,presenttime=0,runningtime=0,rtz1n=0,rtz1f=0,rtz2n=0,rtz2f=0,trigtime=0;
/////////////////////////////proximity.//////////////////////////////////////
//xdata startproximitycountflag=0;
xdata unsigned int switchset=0,switchset2=0,switchset1=0;

xdata unsigned rotationcount=0;
//------Temperature----------------------------------------------------------------/
xdata unsigned int tempResult = 0, adcResult = 0;
xdata unsigned long tempResultAverage = 0;
unsigned char temperature1 = 0;
double tempResistance = 0;
unsigned int counttime=0,counter=0;
unsigned int iterator = 0;
unsigned char highTemp = 0;
unsigned int displaycount=0;
void tempScan(void);
int adcScan_temp(void);
unsigned char timervalue=0;
bit current_state = 0;
bit last_state = 0;
xdata int pr_count= 0;
xdata char screen_page = 0; // stay in page 1 initially after welcome message
/*clock*/
bit BIT_TMP; 
/*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
						    variable declaration routine
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
volatile unsigned char xdata page_buffer[128];
unsigned char rdata;
//xdata char zerodetect=0,etype=0,errortime=0,eaddr=0,erase=0,reportzero=0;
xdata unsigned int counter3=0, counter1=0, counttime2=0;
xdata unsigned int counttime4=0,counttime1=0,switchdisp=0;
xdata unsigned char display_lcd[5];
xdata char amanpress=0;
xdata char loop=0,lcome=0,reg=0,reg7=0,temp=0,icome=0,t3=0;
volatile unsigned int r1, r2, r3;
xdata unsigned char calpress=0,errortime1=0,startpress=0,stoppress=0,menupress=0;
xdata unsigned char r3x=0,count1=0,highbyte=0,lowbyte=0,channel=0,initialenter=0,x=0;
xdata unsigned char waitset=0;
xdata unsigned char sw2 = 0,sw1=0;
//xdata unsigned int ovltimes=0,ivolt=0,current=0,evalue=0,countx=0;
xdata unsigned int rlycutter=0,buffer1=0,bufferx=0,result3=0,result2=0,v_cal=0,cuttime1=0,ontime1=0,cutoffcount=0,cutoffcount1=0,fres=0,frequency=0;
xdata unsigned long resultx=0,resultx2=0,fresx=0,resulty=0,resulta=0,original=0;
xdata unsigned int settings[32],intref=0,ovoltbufx=0,intref1=0,fscan=0,qsec=0;
xdata unsigned int freq1=0,loop2=0,income2=0,ledcount=0;
//xdata signed int fcompensate=0;
//xdata double resultx1=0,resultxy2=0;
xdata unsigned char setreset=0,check=0,decrement=0;
xdata unsigned char scan=0;
xdata char iplowled=0,iphighled=0,oplowled=0,ophighled=0,cutoffled=0,outputon=0,ovlled=0,resetted=0,voltprob=0;
xdata unsigned char writ=0,automansw=0,ovlreset=0,stopkey=0,testkey=0,manualreset=0;
xdata char qmax=0,calib=0,nokey=0,tens=0;
xdata unsigned int dec=0;
xdata unsigned char memsave=0,memsave1=0;
//xdata unsigned int counttime4=0,counttime1=0,switchdisp=0;
unsigned char DP=0;

void set_clock_source(void);
void set_clock_division_factor(unsigned char value);
void init(void);
void portinit(void);
void enabler(char t4);
void delay(char gg);
void timer_init(void);
void lcdinit(void);
void switchscan1(void);
void tempandptywrite(void);
void valuewrite(void);
void adrcal(void);
void adcal_temp(void);
void adcal_switch(void);
void valuewritex(void);
void adcal(void);
void adc_init(void);
void combin(void);
void adcal1(void);
void switchscan(void);
void atodconv(void);
void involtscan(void);
void zccheck(void);
void keyatod(void);
void setconversion(void);
void setmode(void);
void mdiv(void);
//void voltcal(void);
//void docal(void);
void display(void);
void display2(void);
void sline(void);
void fline(void);
void trmsadc(void);
void mult(void);
void delay1(int t8);
void incrout(void);
void keyscan(void);
void dataread(void);
void FlashWrite(void);
unsigned char Read_APROM_BYTE(unsigned int code *u16_addr);
void Write_DATAFLASH_BYTE(unsigned int u16EPAddr, unsigned char u8EPData);
void main()
{
		init();
		delay(100);
		lcdinit();
		automan=0;
		while(1)
		{
    	  if(automan==0)
			  {
							chip=0;
							enabler(0x01);
							menu=0;
					    sw2=1;
							display();
				}
				while(automan==0)//Run mode.
				{
					  //keyscan();
						switchscan1();
	         // switchscan();
					  tempScan();
						if(displaycount>30)
						{
							  screen_page=!screen_page;
					      display();
							  tempandptywrite();
								displaycount=0;
						}	
				}
				
	//			channel = 0x0f;
	//	    result = adcScan();
	//			proximitycount = result;
	//      proximitycount = pr_count;
	//			   	proximitycount=timerhigh*256+TMR0;
	//			  	proximitycount=0;
	//		 			if(proximitycount>0){
	//							count_save=count_save+proximitycount;
	//							buffer=count_save;
	//							address=10;
	//							dualwrite();
	//							proximitycount=0;
	//							timerhigh=0;
	//							TMR0=0;
	//					}

	//					if(count_save>=count_limit){
	//							countfaultflag=1;
	//					}
	//					if(temperature1>=temp_max){
	//							tempfaultflag=1;
	//					}
	//					if((temperature1<(temp_max-5))&&(tempfaultflag==0))
	//					{
	//							tempfaultflag=0;
	//					}
	//					if(countfaultflag==1){
	//							delay1(5);
	//					}

	//					if(tempfaultflag==1){
	//							delay1(5);
	//					}
	
					
						if(automan==1)
						{
							    //writ=0;
									chip=0;
									enabler(0x01);
									menu=0;
							    sw2=1;
									display2();
						}
						while(automan==1)
						{
//										 sline();
//										 enabler('K');
//								     switchscan1();
	              switchscan();
								if((menu_change!=0)&&(menu1==0))
								{
										display2();
										menu1=1;
								}
								setmode();
					 }
     }
}

/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
						   interrupt service routine
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
void Timer_ISR (void) interrupt 16
{
	   T3CON &= ~(1 << 4);   // Clear TF3 (bit4)
 
	      msec++;
        if (msec > 100)
        {
            msec = 0;
            displaycount++;
        }
				      
				if(setrun==0)//SET/RUN press.
				{
						 swactive=0;
						 swrelease=0;
				}

				if(setrun==1&&swrelease==0)//SET/RUN, when pressed becomes==0 and to enter swrelease==0.
				{
						 swactive++;
						 if(swactive>300)//3sec
						 {
									swrelease=1;//To exit to \() for running the loop after change of state of automan, swrelease state is changed.
									swactive=0;
									automan=!automan;//Here the change of state of setting or running mode occurs
						 } 
				}
				
			  current_state = PROXIMITY_SENSOR;   // live read

				if (current_state == 1 && last_state == 0)
				{
						pr_count++;
						if (pr_count > 90)
								pr_count = 0;
				}

				last_state = current_state;		

/*
if(ovlled==1)
{
	rlycutter++;
	if(rlycutter>910)
	{
		ovltimes++;
		rlycutter=0;
	}
}	
if(iphighled==1||iplowled==1||ophighled==1||oplowled==1)
{
	rlycutter++;
	if(rlycutter>980)
	{
		cutoffcount1++;
		rlycutter=0;
	}
}
if(automan==0)
{
swactive=0;
swrelease=0;
}
if(automan==1&&swrelease==0)
{
swactive++;
if((swactive>1000)||((swactive>10)&&(initialenter==0)&&(settings[1]==0)))
{

swrelease=1;
swactive=0;
automansw=!automansw;
initialenter=1;
}
}
qsec++;
if(qsec>1000)//500
     qsec=0;
    
    if(iphighled==1)
    {
			 r3x&=~(1<<6);
			 r3x|=(1<<7);
    }
if(iplowled==1)
{
	  r3x&=~(1<<6);
    if(qsec<500)
			r3x&=~(1<<7);
    if(qsec>500&&ivolt>60)
			r3x|=(1<<7);
}   
if(iphighled==0&&iplowled==0)
{
   r3x&=~(1<<7);
	   r3x|=(1<<6);
}
if(ophighled==1)
	  r3x|=(1<<2);
  
if(oplowled==1)
{
    if(qsec<500)
			 r3x&=~(1<<2);
    if(qsec>500)
			r3x|=(1<<2);
}
if(ophighled==0&&oplowled==0)
	    r3x&=~(1<<2);

if(settings[15]==1&&ovlled==1&&cutoffled==1&&automan==0)
{
msec++;
if(msec>250)
{
msec=0;
sec++;
if(sec>120)//180
{
sec=0;
ovlled=0;
cutoffled=0;
ovlreset=1;
}
}
}
ledcount++;
if(ledcount>500)
{
	ledcount=0;
	count1=0;
}
while(count1<8)
{
dclock=0;
r3x=r3x<<1;
if(CARRY)
{
ddata=1;
dclock=1;
}
if(!CARRY)
{
ddata=0;
dclock=1;
}
count1++;
}
dclock=0;
ddata=0;*/
}

/*----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
											input voltage scan routine
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
//void involtscan(void)
//{
//channel=0x0a;
//trmsadc();
//ivolt=resultx;
//if(automansw==0)
//{
//v_cal=settings[14];
//voltcal();
//ivolt=result;
//}
//}
/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
						    main routine
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
//----------------------------------------------------
// ADC Initialization
//----------------------------------------------------
void adc_init(void)
{
    P24_INPUT_MODE;
    P25_INPUT_MODE;

    SFRS = 0;
    ADCCON1 &= 0xCF;
    ADCCON1 |= (4 << 4);   // ADC clock = Fsys / 16

    SFRS = 2;
    ENABLE1_ADC_CH12;      // Enable analog input on P2.4 (Channel 12)
    ENABLE1_ADC_CH15;      // Enable analog input on P2.5 (Channel 15)
    SFRS = 0;
}

//----------------------------------------------------
// ADC Conversion Function (uses global 'channel')
//----------------------------------------------------
void adcal_temp(void)
{
    ADCCON0 &= 0xF0;          // Clear lower 4 bits (channel select)
    ADCCON0 |= 0x0C;       // Select current channel (0x0C or 0x0F)

    clr_ADCCON0_ADCF;         // Clear ADC flag
    set_ADCCON0_ADCS;         // Start ADC conversion

    while (!(ADCCON0 & SET_BIT7));  // Wait until conversion complete

    temp_adc_result = ((ADCRH << 4) | (ADCRL & 0x0F)); // 12-bit result
    temp_adc_result = temp_adc_result >> 2;                    // Convert to 10-bit
}

void adcal_switch(void)
{
    ADCCON0 &= 0xF0;          // Clear lower 4 bits (channel select)
    ADCCON0 |= 0x0F;       // Select current channel (0x0C or 0x0F)

    clr_ADCCON0_ADCF;         // Clear ADC flag
    set_ADCCON0_ADCS;         // Start ADC conversion

    while (!(ADCCON0 & SET_BIT7));  // Wait until conversion complete

    sw_adc_result = ((ADCRH << 4) | (ADCRL & 0x0F)); // 12-bit result
    sw_adc_result = sw_adc_result >> 2;                    // Convert to 10-bit
}

//----------------------------------------------------
// ADC Scan (averaging one channel)
//----------------------------------------------------
int adcScan_temp(void)
{
    tempResultAverage = 0;
    adcResult = 0;
    for (iterator = 0; iterator < 400; iterator++)
    {
        adcal_temp();                     // Perform one ADC read
        adcResult = temp_adc_result;
        tempResultAverage += adcResult;
    }

    return (tempResultAverage / 400); // Return averaged value
}

void tempScan(void)
{
		delay(14);
	
	  tempResult = adcScan_temp();
	
		tempResistance = 10000 * (tempResult/(1023.0 - tempResult));

		//formula T =  1/(1/T0 + 1/B*ln(R/R0)) ; R - resistance of temperature sensor
		// 1/T0 = 1/298.15 = 0.00315; B = 3950;R0 = 10000; T in celcius = T - 273.15
		//converting from kelvin to celsious,so subtracting with 273.15
		temperature1 = (1/(0.00335 + ((1/3950.0)*log(tempResistance/10000))) - 273.15);

//		if(temperature1 >= 190)//If thermistor is not present
//		{
//			temperature1 = 0;
//		}
}
//----------------------------------------------------
// AtoD Conversion Wrapper (supports both channels)
//----------------------------------------------------
void atodconv(void)
{
    result = 0;

    for (doad = 0; doad < 350; doad++)
    {
        // Safe channel select (donâ€™t overwrite other bits)
        ADCCON0 = (ADCCON0 & 0xF0) | channel;

        if (automansw == 0)
            for (h = 0; h < 35; h++);
        if (automansw == 1)
            for (h = 0; h < 50; h++);

        adcal();
        result = result1 + result;
    }

    result = result / 350;
}


void set_clock_source(void)
{
	set_CKEN_HIRCEN;         
  while((CKSWT & SET_BIT5) == 0);
}

void set_clock_division_factor(unsigned char value)
{
  CKDIV = value;
}

void timer_init(void)
{
	T3CON=0x04;
	RL3=0x18;
	RH3=0xFC;
	EIE1=0x02;
	IE |=0x80;
	T3CON|=(1<<3);
}

void portinit(void)
{
	dclock=0;
	ddata=0;
	
	   //lcd pins
	SFRS=0;
	P0M1&=0x00;
	P0M2|=0xFF;
	P0=0x00;
  //rs,in&out rly,triac ,led driver.
	SFRS=0;
	P1M1&=0x00;
	P1M2|=0x5F;
	P1=0x00;
	
	P1M1 |= 0x02;   // bit1 = 1 ? input mode
	P1M2 &= ~0x02;  // bit1 = 0

	 //mclr,led driver, in& out selection,ct& switch
	SFRS=2;
	P2M1|=0x3c;
	P2M1&=~(1<<1);
	P2M2|=0x02;
	P2=0x00;

	//enable& buzzer
	SFRS=0;
	P3M1&=0x00;
	P3M2|=0x28;
	P3=0x00;
}

void init(void)
{
 set_clock_source();
 portinit();
 timer_init();
 adc_init();
}

void enabler1(char ladr,char ldata)
{
    chip=0;
    enabler(ladr);
    delay(2);
    chip=1;
    enabler(ldata);
    delay(2);
}
/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
						    main routine
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
						    main routine
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
void valuewrite(void)
{
			chip=1;

			if(menu==0||menu==1)
			{
					for(ibm=1;ibm<4;ibm++)
					{
								temp=dbuf[ibm];
								enabler(temp);
								delay(0x01);
					}
			//  enabler(':');
			}
			if(menu==2)
			{
					temp=dbuf[1];
								enabler(temp);
								delay(0x01);
					enabler('.');
					for(ibm=2;ibm<4;ibm++)
					{
								temp=dbuf[ibm];
								enabler(temp);
								delay(0x01);
					}
			}			
      if(menu==3)
			{
					for(ibm=1;ibm<5;ibm++)
					{
								temp=dbuf[ibm];
								enabler(temp);
								delay(0x01);
					}
			}			
			/*if(menu==5)
			{
					for(ibm=1;ibm<4;ibm++)
					{
					temp=dbuf[ibm];
					enabler(temp);
					delay(0x01);

					}
			}
			if(menu==6 || menu==7)
			{
					for(ibm=1;ibm<3;ibm++)
					{
					temp=dbuf[ibm];
					enabler(temp);
					delay(0x01);
					}
			}
			*/
}

/*---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
						    main routine
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

void lcdinit(void)	
{
	  reg=0;
    chip=0;
		while(reg<15)
		{
				reg7=init2[reg];
				enabler(reg7);
				reg++;
				if(reg==14)
					return;
				reg7=init2[reg];
				delay(reg7);
				reg++;
		}
}
/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
								enable routine	
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
void enabler(char t4)		
{
		//PORTB=t4;
		P0=t4;
		enab=0;
		for(r3=0;r3<100;r3++);
		enab=1;
}

void divcommon(void)
{
//    resultx1=resultx1/2;
}

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
											split routine
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
void delay(char gg)
{
	  TMOD|=0x01;
	  TH0=0xfe;
		TL0=0xf5;//200us
	  TR0=1;
    for(k=0;k<gg;k++)
    {
			TH0=0xfe;
			TL0=0xf5;//200us
			TF0=0;
			while(TF0==0);
    }
		TR0=0;
}

/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
											set volt routine
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
void fline(void)
{
		chip=0;
		enabler(0x80);
		delay(2);
		chip=1;
}
/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
											main routine
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

void sline(void)
{
		chip=0;
		enabler(0xc0);
		delay(1);
		chip=1;
}

/*****************************************Main Display*****************************************************/
void display(void)
{
	        if(screen_page == 0)
					{
								fline();
								for(t3=0;t3<16;t3++)
								{
										chip=1;
			//							temp=temperaturestring[t3];//Live Temperature
										temp = machine_status[t3];
										enabler(temp);
										delay(1);
								}

								sline();
								for(t3=0;t3<16;t3++)
								{
										chip=1;
			//		        temp=proximitystring[t3];//Live Count.
										temp = machine_line2[t3]; 
										enabler(temp);
										delay(5);

								}
					}
					if(screen_page == 1)
					{
								fline();
								for(t3=0;t3<16;t3++)
								{
										chip=1;
			//							temp=temperaturestring[t3];//Live Temperature
										temp = coolant_status[t3];
										enabler(temp);
										delay(1);
								}

								sline();
								for(t3=0;t3<16;t3++)
								{
										chip=1;
			//		        temp=proximitystring[t3];//Live Count.
										temp = coolant_line2[t3]; 
										enabler(temp);
										delay(5);

								}
					}

					chip=0;
					enabler(0x0c);
					delay(0x01);
}

void display2(void)
{
			fline();
			chip=1;
			for(t3=0;t3<16;t3++)
			{
					temp=fline1[t3];//SET mode
					enabler(temp);
					delay(1);
			}
			/**************************************MENU SELECTION***********************************************/
			sline();
			for(t3=0;t3<16;t3++)
			{
					if(menu==0)//Temperature max display.
							temp=temp_maximum[t3];
					if(menu==1)//oil level display.
							temp=oil_lowlvl[t3];
					if(menu==2)
							temp=max_vib[t3];
					if(menu==3)
							temp=run_time[t3];
					enabler(temp);
					delay(5);
			}
			/***********************Digits displaying**************************************************/
			setconversion();
			chip=0;
			enabler(0x0c);
			delay(0x01);
}

void setmode(void)
{
    switchscan();
	  switchscan1();
	  switchset1=1;
		if(waitset==0)
		{	
			    if(((sw2==1)&&(automan==1)&&(setswitch==0)&&(menu<=3)))  //menu switch for setting temp,oil level etc.,
					{
												    counter++;	 
											      if((counter>25)&&(automan==1)&&(switchset==1))
														{
																	counter=0;
																	switchset=0;
																	switchset1=1;
																	menu = menu + 1;
																	if(menu>3)
																			menu=0;
																	display2();
														//     if(memsave1==1)
														//     {
														//      memsave=1;
														//      memsave1=0;
														//    }
														//							if((menu==0)||(menu==1)||(menu==2)||(menu==3))
														//							{
														//										counter4=80;
														//							}
													}
					}
/*******************************************************************************************/					
					if(((menu==0)||(menu==2)||(menu == 3))&&(switchset1==1))
					{    
						
											counter2++;
										//	if(counter2<counter4)
										//	{
										//		      tempmax = 455;
										//					setswitch=1;
										//					if(menu==0)
										//					{
															//		display_lcd[1]=0;
															//		display_lcd[2]=20;
															//		display_lcd[3]=19;
										//					}
										//	}				
												if((counter2>counter4))
												{
		
														setswitch=0;
														if(menu==0)
														{
															dec=tempmax;
															if(dec>100)
																	dec=5;													
														}
										        if(menu==2)
														{
															dec=max_vib_var;
															if(dec>600)
																	dec=150;													
														}
														if(menu==3)
														{
															dec=run_time_var;
															if(dec>9999)
																	dec=0;													
														}
														setconversion();//1
							//							switchset1=0;
														counter2=0;
														switchpress=1;
												}
							//	}
										/*******************************************************************************/		 
									if((sw1==1)&&(switchpress==1)&&((menu==0)||(menu == 2)||(menu==3)))  	
									{
														//switchpress=0;
														counter1++;
														setreset=0;
														
														if(counter1>100)
														{
														//memsave1=1;
																counttime4=1;
																counter1=0;
														}
														
														if((counttime4==1)&&(check==1))
														{
																	counter3=counter3-5;
																	check=0;
																	if(counter3<=5)
																	{
																			counter3=5;
																	}
														}
														
														if((counter1>20)&&(switchset2==1)&&(counttime4==0))
														{
															//		memsave1=1;
																	counter1=0;
																	switchset2=0;
																	decrement=1;
														}
														
														if((counter1>counter3)&&(counttime4==1))
														{
																	 decrement=0;
																	 check=1;
																	 counter1=0;
																	 switchset2=0;
																		 if(menu==0)
																		 {
																				dec=dec+1;
																				if(menu==0)
																				{
																								if(dec>100)
																										dec=5;
																								tempmax=dec;																			
																				}
																				setconversion();//2
																	   }
																		 if(menu==2)
																		 {
																				dec=dec+1;
																				if(menu==2)
																				{
																								if(dec>600)
																										dec=150;
																								max_vib_var=dec;																			
																				}
																				setconversion();//2
																	   }
																		 if(menu==3)
																		 {
																				dec=dec+1;
																				if(menu==3)
																				{
																								if(dec>9999)
																										dec=0;
																								run_time_var=dec;																			
																				}
																				setconversion();//2
																	   }
														}
								}
									////////////////////////////////////////////
								if((decrement==1)&&(switchset2==1))
								{
										decrement=0;
										switchset2=0;
										if(menu==0)
										{
												if(dec==0)
														dec=1-dec;
												if(dec>0)
														dec=dec-1;
												if(menu==0)
												{
															if(dec<5)
																	dec=100;
															tempmax = dec;
												}
												
												setconversion();//3
										}
										if(menu==2)
										{
												if(dec==0)
														dec=1-dec;
												if(dec>0)
														dec=dec-1;
												if(menu==2)
												{
															if(dec<150)
																	dec=600;
															max_vib_var = dec;
												}
												setconversion();//3
										}
										if(menu==3)
										{
												if(dec==0)
														dec=1-dec;
												if(dec>0)
														dec=dec-1;
												if(menu==2)
												{
															if(dec<0)
																	dec=9999;
															run_time_var = dec;
												}
												setconversion();//3
										}
								}
					}
	  /******************************************************************************/
		      if((menu==1)&&(switchset1==1))
					{
								counter2++;
				//			setswitch=0;
										if((sw1==1)&&(switchpress==1)&&(menu==1)&&(counter2>25)) 
										{
													oil_low_level += 20;
											
											    if(oil_low_level>80){
																oil_low_level = 20;
													}
												  setconversion();
													counter2 = 0;
										} 	
					} 
					
		}
}

void setconversion(void)
{
    if(menu==0)
    {
        display_lcd[1]= (tempmax/100)+0x30;
        display_lcd[2]=((tempmax%100)/10)+0x30;
        display_lcd[3]=((tempmax%100)%10)+0x30;
			    chip=0;
					enabler(0xca);//Second line 10th position
					delay(0x01);
			    chip=1;
		      for(ibm=1;ibm<4;ibm++)
					{
								temp=display_lcd[ibm];
								enabler(temp);
								delay(0x01);
					}
    }
		if(menu==1)
    {
        display_lcd[1]= (oil_low_level/100)+0x30;
        display_lcd[2]=((oil_low_level%100)/10)+0x30;
        display_lcd[3]=((oil_low_level%100)%10)+0x30;
			  chip=0;
				enabler(0xcc);//Second line 12th position
				delay(0x01);
			  chip=1;
		    for(ibm=1;ibm<4;ibm++)
				{
							temp=display_lcd[ibm];
							enabler(temp);
							delay(0x01);
				}
    }
		if(menu==2)
    {
        display_lcd[1]= (max_vib_var/100)+0x30;
        display_lcd[2]=((max_vib_var%100)/10)+0x30;
        display_lcd[3]=((max_vib_var%100)%10)+0x30;
			  chip=0;
				enabler(0xc8);//Second line 12th position
				delay(0x01);
			  chip=1;
				temp=display_lcd[1];
				enabler(temp);
				delay(0x01);
				enabler('.');
				for(ibm=2;ibm<=3;ibm++)
				{
						temp=display_lcd[ibm];
						enabler(temp);
						delay(0x01);
				}
    }
		if(menu==3)
    {
		    display_lcd[1] = (run_time_var/1000) + 0x30;
        display_lcd[2] = ((run_time_var%1000)/100) + 0x30;
        display_lcd[3] = ((run_time_var%100)/10) + 0x30;
        display_lcd[4] = ((run_time_var%100)%10) + 0x30;
     
			  chip=0;
				enabler(0xca);//Second line 10th position
				delay(0x01);
			  chip=1;
		    for(ibm=1;ibm<5;ibm++)
				{
							temp=display_lcd[ibm];
							enabler(temp);
							delay(0x01);
				}
    }
}

void switchscan(void)
{
		  resultx2=0;
      for(scan=0;scan<250;scan++)
      {   
       	 adcal_switch();
         resultx2=sw_adc_result+resultx2;
      }
		 
	    result=resultx2/250;
			
			if((result>380)&&(result<450))//set/run
			{
						setruntime++;
						if(setruntime>1)
						{
								setrun=1;
						}
			}
		 	if((result>480)&&(result<530))//menukey
			{
				    sw2=1;
	          sw1=0;
//						setruntime=0;
//						menutime++;

//						if(menutime>1)
//						{
//								setruntime=0;
//						    sw2=1;
//	              sw1=0;
//						}
			}
			
			if((result>680)&&(result<730))//inc key
			{
				   sw1=1;
           sw2=0;
			}
			
		  if(result>800)
			{
					setruntime=0;
					setrun=0;
					waitset=0;
				  switchset=1;
          switchset2=1;
				  sw2=0;
				  sw1=0;
				  counter1=0;
          counter3=50;
          counttime2=5;
          counttime=0;
          counttime4=0;
          counttime1=2;
			}
}	

void switchscan1(void)  //run mode
{
		  resultx2=0;
      for(scan=0;scan<50;scan++)
      {   
       	 adcal_switch();
         resultx2=sw_adc_result+resultx2;
      }
		 
	    result=resultx2/50;
			
		 	if((result>380)&&(result<450))//set/run
			{
						setruntime++;
						
						if(setruntime>1)
						{
								setrun=1;
						}
			}
			
		  if(result>800)
			{
				setrun = 0;
				setruntime = 0;
				waitset=0;
        sw1=0;
        sw2=0;
        switchset=1;
        switchset2=1;
        counter1=0;
        counter3=50;
        counttime2=5;
        counttime=0;
        counttime4=0;
        counttime1=2;
        switchdisp=0;	
			}
//		 if(smode==1 && smode1==0)
//		 {
//		 
//						smode1=0;
//						led=0;
//						display[1]=5;
//						display[2]=14;
//						display[3]=23;
//						dp1=0;
//						dp2=0;
//		 }
//		 
//		if((vref2>200)&&(vref2<=280))//both switch pr
//		{
//	
//			if(press==1)
//			{
//				smode=!smode; 
//				
//				if(smode==1)
//				{
//					smode1=0;
//					led=0;
//					rmenu=1;
//					scrollingcount=0;
//				}
//				
//					if(smode==0)
//					{
//					rmenu=1;
//					scrollingcount=0;
//					led=1;
//					}
//					
//					
//				switchset2=0;
//				counttime=0;
//				waitset=1;
//				
//				
//				if(smode==1)
//				{	
//						// to display "set"
//						display[1]=5;
//						display[2]=14;
//						display[3]=23;
//						dp=0;
//						counter=0;
//						setswitch=0;	
//				}
//				
//				press=0;
//			}
//		
//		}
//		
//		if((vref2>300)&&(vref2<=350))//switch1 press  - Menu key
//    {
//	
//			sw2=1;
//	    sw1=0;
//			
//    }

//		if((vref2>450)&&(vref2<=550))//switch 2 press - Inc/Dec key
//    {
//				
//        sw1=1;
//        sw2=0;
//			
//				if(smode==0&&olr==1)
//				{
//					olr=0;
//					rolrx=0;
//					yolrx=0;
//					bolrx=0;
//				} 
//    }
//		
//		if((vref2>990))//no switch press
//    {
//				waitset=0;
//        press=1;
//        sw1=0;
//        sw2=0;
//        switchset=1;
//        switchset2=1;
//        counter1=0;
//        counter3=50;
//        counttime2=5;
//        counttime=0;
//        counttime4=0;
//        counttime1=2;
//        switchdisp=0;	
//				rmenupress=0;
//    }

}



/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
								                      Aprom read& write routine
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
unsigned char Read_APROM_BYTE(unsigned int code *u16_addr)
{
    //UINT8 rdata;
    rdata = *u16_addr >> 8;
    return rdata;
}

void Write_DATAFLASH_BYTE(unsigned int u16EPAddr, unsigned char u8EPData)
{
    unsigned char looptmp = 0;
    unsigned int u16_addrl_r;
    unsigned int RAMtmp;

    //Check page start address
    u16_addrl_r = (u16EPAddr / 128) * 128;

    //Save APROM data to XRAM0
    for (looptmp = 0; looptmp < 0x80; looptmp++)
    {
        RAMtmp = Read_APROM_BYTE((unsigned int code *)(u16_addrl_r + looptmp));
        page_buffer[looptmp] = RAMtmp;
    }

    // Modify customer data in XRAM
    page_buffer[u16EPAddr & 0x7f] = u8EPData;

    //Erase APROM DATAFLASH page
    IAPAL = u16_addrl_r & 0xff;
    IAPAH = (u16_addrl_r >> 8) & 0xff;
    IAPFD = 0xFF;
    set_CHPCON_IAPEN;
    set_IAPUEN_APUEN;
    IAPCN = 0x22;
    set_IAPTRG_IAPGO;

    //Save changed RAM data to APROM DATAFLASH
    set_CHPCON_IAPEN;
    set_IAPUEN_APUEN;
    IAPCN = 0x21;

    for (looptmp = 0; looptmp < 0x80; looptmp++)
    {
        IAPAL = (u16_addrl_r & 0xff) + looptmp;
        IAPAH = (u16_addrl_r >> 8) & 0xff;
        IAPFD = page_buffer[looptmp];
        set_IAPTRG_IAPGO;
    }

    clr_IAPUEN_APUEN;
    clr_CHPCON_IAPEN;
}

void FlashWrite(void)
{
	IE&=~(1<<7);
	for(loop=1,loop2=1;loop<32,loop2<61;loop++,loop2+=2)
	{
				 highbyte=((settings[loop]&(0xFF00))>>8);
				 lowbyte=(settings[loop]&(0x00FF));
				 Write_DATAFLASH_BYTE(16800+loop2,highbyte);
				 Write_DATAFLASH_BYTE(16800+loop2+1,lowbyte);
	}
	IE|=(1<<7);
}

void dataread(void)
{
	IE&=~(1<<7);
 for(lcome=1,income2=1;lcome<32,income2<61;lcome++,income2+=2)
    {
       
           Read_APROM_BYTE(16800+income2);
			         highbyte=rdata;
			     Read_APROM_BYTE(16800+income2+1);
			       lowbyte=rdata;
			 settings[lcome]=((highbyte<<8)|(lowbyte));
     //   if(settings[lcome]>9999)
       //     settings[lcome]=0;
      }
    for(lcome=15;lcome<18;lcome++)
    {
    if(settings[lcome]!=2)
       settings[lcome]=1;
    }
		for(lcome=19;lcome<32;lcome++)
    {
    if(settings[lcome]>=65530)
       settings[lcome]=0;
    }
	  	IE|=(1<<7);
		  if(settings[1]>=65530)//setvolt
			settings[1]=200;
			if(settings[2]>=65530)//sens
			settings[2]=3;
			if(settings[3]>=65530)//ophihgh
			settings[3]=255;
			if(settings[4]>=65530)//oplow
			settings[4]=170;
			if(settings[5]>=65530)//iphigh
			settings[5]=280;
			if(settings[6]>=65530)//iplow
			settings[6]=170;
			if(settings[7]>=65530)//ctfact
			settings[7]=174;                                           
			if(settings[8]>=65530)//ovl
			settings[8]=35;
			if(settings[9]>=65530)//icut
			settings[9]=3;
			if(settings[10]>=65530)//vcut
			settings[10]=3;
			if(settings[11]>=65530)//on delay
			settings[11]=3;
			if(settings[18]>=65530)//on delay
			settings[18]=0;

}

void tempandptywrite(void)
{

	if(screen_page == 1)
	{
				sline();
		    chip=0;
				enabler(0xC4);
				delay(5);

				chip=1;
				//enabler((temperature1/100)+0x30);
				//delay(2);
				
				enabler(((temperature1%100)/10)+0x30);
				delay(2);

				enabler((temperature1%10)+0x30);
				delay(2);
	}
	if(!screen_page)
	{
		  sline();
			chip=0;
			enabler(0xc2);
			delay(1);

			chip=1;
		
			enabler((pr_count/1000)+0x30);
			delay(1);
		
	  	enabler(((pr_count%1000)/100)+0x30);
			delay(1);
			
			enabler(((pr_count%100)/10)+0x30);
			delay(1);

			enabler((pr_count%10)+0x30);
			delay(1);
	}

	chip=0;
	enabler(0x0c);
	delay(0x01);

}

void delay1(int t8)
{
	for(r1=0;r1<t8;r1++)
	{
		for(r2=0;r2<250;r2++)
		{
			for(r3=0;r3<250;r3++);
		}
	}
}


